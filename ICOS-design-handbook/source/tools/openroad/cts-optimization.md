# OpenROAD - CTS & Optimization

Clock Tree Synthesis (CTS) builds and balances the clock network, ensuring that all sequential elements (flip-flops, latches) receive the clock signal with minimal skew.
After CTS, OpenROAD performs timing-driven optimizations to fix setup/hold violations and improve performance or power.

### Official documentation:

- OpenROAD CTS (TritonCTS) README
- OpenROAD Resizer (Optimization) README
- OpenROAD-flow-scripts CTS Tutorial

## 1. Clock Tree Synthesis (CTS)

CTS is executed using the command clock_tree_synthesis, which invokes TritonCTS to automatically generate the clock buffers and wires.

Basic CTS Example
```
# Load placed design
read_def results/placement.def

# Define the clock network
create_clock -period 10 -name clk [get_ports clk]

# Run CTS
clock_tree_synthesis \
  -root_buf CLKBUF_X3 \
  -buf_list {CLKBUF_X3 CLKBUF_X2 CLKBUF_X1}
```

This creates a clock tree with buffers from the list and inserts them along the clock paths.

### Additional options
| Option            | Description                                     |
| ----------------- | ----------------------------------------------- |
| `-root_buf`       | Defines the top-level buffer for the clock root |
| `-buf_list`       | List of buffer cells used in the tree           |
| `-target_skew`    | Target maximum skew (in ps)                     |
| `-target_latency` | Expected latency from clock source to sinks     |

### Example: specify target skew and routing layer
```
clock_tree_synthesis \
  -root_buf CLKBUF_X3 \
  -buf_list {CLKBUF_X3 CLKBUF_X2} \
  -target_skew 150 \
  -target_latency 2000 \
  -routing_layers {metal2 metal5}
```

ðŸ‘‰ Reference example:
clock_tree_synthesis1.tcl

## 2. Post-CTS Optimization

After CTS, the design timing changes due to new buffers and wire capacitances.
Resizer and OpenSTA are used together to fix any setup/hold violations.

### Optimization stages

1. Setup optimization â€“ fixes long-path violations (adds buffers, upsizes cells).
2. Hold optimization â€“ fixes short-path violations (inserts delay buffers).
3. Power optimization â€“ optional resizing to reduce leakage or dynamic power.

Example: Setup and Hold Optimization
```
# Setup-driven optimization
opt_design -setup

# Hold-driven optimization
opt_design -hold
```

You can specify which violations to fix using reports generated by report_timing or report_worst_slack.

Example combined optimization:
```
opt_design -setup -hold
```

### Additional optimization commands
| Command              | Description                                                         |
| -------------------- | ------------------------------------------------------------------- |
| `repair_timing`      | Automatically fixes setup/hold violations                           |
| `repair_design`      | Generic optimization of cell sizing and buffer insertion            |
| `optimize_mets`      | Metal layer optimization for better routing and capacitance control |
| `report_timing`      | Show current timing violations                                      |
| `report_worst_slack` | Summarize the worst slack values for setup and hold                 |
| `report_power`       | Estimate power after resizing and buffering                         |

## 3. Example CTS and Optimization Script
```
# === Clock Tree Synthesis ===
read_lef tech.lef
read_liberty tech.lib
read_def results/placement.def
create_clock -period 10 -name clk [get_ports clk]
clock_tree_synthesis \
  -root_buf CLKBUF_X3 \
  -buf_list {CLKBUF_X3 CLKBUF_X2 CLKBUF_X1} \
  -target_skew 150

write_def results/cts.def

# === Optimization ===
read_def results/cts.def
report_timing
opt_design -setup -hold
repair_timing
write_def results/optimized.def
```

## 4. Outputs
| File            | Description                                                |
| --------------- | ---------------------------------------------------------- |
| `cts.def`       | Design DEF file after clock tree insertion                 |
| `cts.log`       | CTS run log and statistics (buffers inserted, skew report) |
| `optimized.def` | Post-optimization DEF ready for routing                    |
| `timing.rpt`    | Setup and hold timing summary                              |
| `power.rpt`     | Optional power report from Resizer                         |

## 5. Verification after CTS

After CTS and optimization, always re-run Static Timing Analysis (STA) to verify the new clock paths:
```
read_def results/optimized.def
report_worst_slack
report_timing -path_delay min_max
```

ðŸ‘‰ Reference modules:

CTS (TritonCTS) source code

Resizer optimization examples

## 6. Summary of Key Commands
| Step             | Command                                               | Description                         |
| ---------------- | ----------------------------------------------------- | ----------------------------------- |
| **CTS**          | `clock_tree_synthesis`                                | Build and balance the clock network |
|                  | `create_clock`                                        | Define primary clock signal         |
| **Optimization** | `opt_design`                                          | Fix setup/hold timing               |
|                  | `repair_timing`                                       | Auto repair of violations           |
| **Reporting**    | `report_timing`, `report_power`, `report_worst_slack` | Validate results                    |

## 7. Typical next step

Once CTS and optimization are complete, proceed with Routing, where the tool performs global and detailed routing based on the finalized clock and data paths.

ðŸ‘‰ See also:
{doc}routing